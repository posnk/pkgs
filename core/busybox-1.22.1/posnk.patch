diff -rupN busybox-1.22.1/coreutils/chown.c ../src3m/busybox-1.22.1/coreutils/chown.c
--- busybox-1.22.1/coreutils/chown.c	2014-01-20 03:38:10.000000000 +0100
+++ ../src3m/busybox-1.22.1/coreutils/chown.c	2020-05-16 03:16:19.161660676 +0200
@@ -125,12 +125,11 @@ int chown_main(int argc UNUSED_PARAM, ch
 
 	/* This matches coreutils behavior (almost - see below) */
 	param.chown_func = chown;
-	if (OPT_NODEREF
 	/* || (OPT_RECURSE && !OPT_TRAVERSE_TOP): */
-	IF_DESKTOP( || (opt & (BIT_RECURSE|BIT_TRAVERSE_TOP)) == BIT_RECURSE)
-	) {
-		param.chown_func = lchown;
-	}
+	//IF_DESKTOP( || (opt & (BIT_RECURSE|BIT_TRAVERSE_TOP)) == BIT_RECURSE)
+	//) {
+	//	param.chown_func = lchown;
+	//}
 
 	flags = ACTION_DEPTHFIRST; /* match coreutils order */
 	if (OPT_RECURSE)
diff -rupN busybox-1.22.1/coreutils/ls.c ../src3m/busybox-1.22.1/coreutils/ls.c
--- busybox-1.22.1/coreutils/ls.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/coreutils/ls.c	2020-05-16 03:16:19.161660676 +0200
@@ -335,7 +335,7 @@ struct dnode {
 	time_t    dn_ctime;
 #endif
 	ino_t     dn_ino;
-	blkcnt_t  dn_blocks;
+	//blkcnt_t  dn_blocks;
 	nlink_t   dn_nlink;
 	uid_t     dn_uid;
 	gid_t     dn_gid;
@@ -521,8 +521,8 @@ static NOINLINE unsigned display_single(
 	if (G.all_fmt & LIST_INO)
 		column += printf("%7llu ", (long long) dn->dn_ino);
 //TODO: -h should affect -s too:
-	if (G.all_fmt & LIST_BLOCKS)
-		column += printf("%6"OFF_FMT"u ", (off_t) (dn->dn_blocks >> 1));
+	//if (G.all_fmt & LIST_BLOCKS)
+	//	column += printf("%6"OFF_FMT"u ", (off_t) (dn->dn_blocks >> 1));
 	if (G.all_fmt & LIST_MODEBITS)
 		column += printf("%-10s ", (char *) bb_mode_string(dn->dn_mode));
 	if (G.all_fmt & LIST_NLINKS)
@@ -754,7 +754,7 @@ static struct dnode *my_stat(const char
 	cur->dn_ctime  = statbuf.st_ctime ;
 #endif
 	cur->dn_ino    = statbuf.st_ino   ;
-	cur->dn_blocks = statbuf.st_blocks;
+//	cur->dn_blocks = statbuf.st_blocks;
 	cur->dn_nlink  = statbuf.st_nlink ;
 	cur->dn_uid    = statbuf.st_uid   ;
 	cur->dn_gid    = statbuf.st_gid   ;
@@ -887,9 +887,9 @@ static int sortcmp(const void *a, const
 		dif = S_ISDIR(d2->dn_mode) - S_ISDIR(d1->dn_mode);
 	} else
 #if defined(HAVE_STRVERSCMP) && HAVE_STRVERSCMP == 1
-	if (sort_opts == SORT_VERSION) {
-		dif = strverscmp(d1->name, d2->name);
-	} else
+//	if (sort_opts == SORT_VERSION) {
+//		dif = strverscmp(d1->name, d2->name);
+//	} else
 #endif
 	if (sort_opts == SORT_EXT) {
 		dif = strcmp(strchrnul(d1->name, '.'), strchrnul(d2->name, '.'));
diff -rupN busybox-1.22.1/coreutils/mknod.c ../src3m/busybox-1.22.1/coreutils/mknod.c
--- busybox-1.22.1/coreutils/mknod.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/coreutils/mknod.c	2020-05-16 03:16:19.161660676 +0200
@@ -26,7 +26,7 @@
 //usage:       "$ mknod /dev/fd0 b 2 0\n"
 //usage:       "$ mknod -m 644 /tmp/pipe p\n"
 
-#include <sys/sysmacros.h>  // For makedev
+//#include <sys/sysmacros.h>  // For makedev
 
 #include "libbb.h"
 #include "libcoreutils/coreutils.h"
diff -rupN busybox-1.22.1/coreutils/touch.c ../src3m/busybox-1.22.1/coreutils/touch.c
--- busybox-1.22.1/coreutils/touch.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/coreutils/touch.c	2020-05-16 03:16:19.161660676 +0200
@@ -166,11 +166,11 @@ int touch_main(int argc UNUSED_PARAM, ch
 
 	do {
 		int result;
-		result = (
-#if ENABLE_FEATURE_TOUCH_NODEREF
-			(opts & OPT_h) ? lutimes :
-#endif
-			utimes)(*argv, (reference_file || date_str) ? timebuf : NULL);
+		result = 0;//(
+//#if ENABLE_FEATURE_TOUCH_NODEREF
+//			(opts & OPT_h) ? lutimes :
+//#endif
+//			utimes)(*argv, (reference_file || date_str) ? timebuf : NULL);
 		if (result != 0) {
 			if (errno == ENOENT) { /* no such file? */
 				if (opts & OPT_c) {
@@ -181,8 +181,8 @@ int touch_main(int argc UNUSED_PARAM, ch
 				fd = open(*argv, O_RDWR | O_CREAT, 0666);
 				if (fd >= 0) {
 					xclose(fd);
-					if (reference_file || date_str)
-						utimes(*argv, timebuf);
+					//if (reference_file || date_str)
+					//	utimes(*argv, timebuf);
 					continue;
 				}
 			}
diff -rupN busybox-1.22.1/include/libbb.h ../src3m/busybox-1.22.1/include/libbb.h
--- busybox-1.22.1/include/libbb.h	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/include/libbb.h	2020-05-16 03:16:19.161660676 +0200
@@ -9,15 +9,15 @@
  */
 #ifndef LIBBB_H
 #define LIBBB_H 1
-
 #include "platform.h"
-
+#define fgets_unlocked fgets
+#define fputs_unlocked fputs
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
-#include <netdb.h>
+//#include <netdb.h>
 #include <setjmp.h>
 #include <signal.h>
 #if defined __UCLIBC__ /* TODO: and glibc? */
@@ -37,15 +37,26 @@
 #include <libgen.h> /* dirname,basename */
 #undef basename
 #define basename dont_use_basename
-#include <poll.h>
+//#include <poll.h>
 #include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/socket.h>
+//#include <sys/mman.h>
+//#include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <sys/types.h>
 #ifndef major
-# include <sys/sysmacros.h>
+//# include <sys/sysmacros.h>
+#define MINORBITS       8
+#define MINORMASK       ((1U << MINORBITS) - 1)
+
+#define major(d) ((d & 0xFF00) >> 8)
+#define minor(d) (d & 0xFF)
+
+#define MKDEV(m,n) (((m << 8) & 0xFF00) | (n & 0xFF))
+
+#define makedev(m,n) (((m << 8) & 0xFF00) | (n & 0xFF))
+
+
 #endif
 #include <sys/wait.h>
 #include <termios.h>
@@ -66,10 +77,10 @@
 # define endgrent() ((void)0)
 #endif
 #ifdef HAVE_MNTENT_H
-# include <mntent.h>
+//# include <mntent.h>
 #endif
 #ifdef HAVE_SYS_STATFS_H
-# include <sys/statfs.h>
+//# include <sys/statfs.h>
 #endif
 /* Don't do this here:
  * #include <sys/sysinfo.h>
@@ -113,7 +124,7 @@
 #elif defined __APPLE__
 # include <netinet/in.h>
 #else
-# include <arpa/inet.h>
+//# include <arpa/inet.h>
 # if !defined(__socklen_t_defined) && !defined(_SOCKLEN_T_DECLARED)
 /* We #define socklen_t *after* includes, otherwise we get
  * typedef redefinition errors from system headers
@@ -499,7 +510,7 @@ struct fd_pair { int rd; int wr; };
 /* Useful for having small structure members/global variables */
 typedef int8_t socktype_t;
 typedef int8_t family_t;
-struct BUG_too_small {
+/*struct BUG_too_small {
 	char BUG_socktype_t_too_small[(0
 			| SOCK_STREAM
 			| SOCK_DGRAM
@@ -518,10 +529,10 @@ struct BUG_too_small {
 #ifdef AF_NETLINK
 			| AF_NETLINK
 #endif
-			/* | AF_DECnet */
-			/* | AF_IPX */
+			/ * | AF_DECnet * /
+			/ * | AF_IPX * /
 			) <= 127 ? 1 : -1];
-};
+};*/
 
 
 void parse_datestr(const char *date_str, struct tm *ptm) FAST_FUNC;
@@ -530,11 +541,11 @@ char *strftime_HHMMSS(char *buf, unsigne
 char *strftime_YYYYMMDDHHMMSS(char *buf, unsigned len, time_t *tp) FAST_FUNC;
 
 int xsocket(int domain, int type, int protocol) FAST_FUNC;
-void xbind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen) FAST_FUNC;
+//void xbind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen) FAST_FUNC;
 void xlisten(int s, int backlog) FAST_FUNC;
-void xconnect(int s, const struct sockaddr *s_addr, socklen_t addrlen) FAST_FUNC;
-ssize_t xsendto(int s, const void *buf, size_t len, const struct sockaddr *to,
-				socklen_t tolen) FAST_FUNC;
+//void xconnect(int s, const struct sockaddr *s_addr, socklen_t addrlen) FAST_FUNC;
+//ssize_t xsendto(int s, const void *buf, size_t len, const struct sockaddr *to,
+//				socklen_t tolen) FAST_FUNC;
 /* SO_REUSEADDR allows a server to rebind to an address that is already
  * "in use" by old connections to e.g. previous server instance which is
  * killed or crashed. Without it bind will fail until all such connections
@@ -546,36 +557,36 @@ int setsockopt_broadcast(int fd) FAST_FU
 int setsockopt_bindtodevice(int fd, const char *iface) FAST_FUNC;
 /* NB: returns port in host byte order */
 unsigned bb_lookup_port(const char *port, const char *protocol, unsigned default_port) FAST_FUNC;
-typedef struct len_and_sockaddr {
-	socklen_t len;
-	union {
-		struct sockaddr sa;
-		struct sockaddr_in sin;
+//typedef struct len_and_sockaddr {
+//	socklen_t len;
+//	union {
+//		struct sockaddr sa;
+//		struct sockaddr_in sin;
 #if ENABLE_FEATURE_IPV6
-		struct sockaddr_in6 sin6;
+//		struct sockaddr_in6 sin6;
 #endif
-	} u;
-} len_and_sockaddr;
-enum {
-	LSA_LEN_SIZE = offsetof(len_and_sockaddr, u),
-	LSA_SIZEOF_SA = sizeof(
-		union {
-			struct sockaddr sa;
-			struct sockaddr_in sin;
-#if ENABLE_FEATURE_IPV6
-			struct sockaddr_in6 sin6;
-#endif
-		}
-	)
-};
+//	} u;
+//} len_and_sockaddr;
+//enum {
+//	LSA_LEN_SIZE = offsetof(len_and_sockaddr, u),
+//	LSA_SIZEOF_SA = sizeof(
+//		union {
+//			struct sockaddr sa;
+//			struct sockaddr_in sin;
+//#//if ENABLE_FEATURE_IPV6
+//			struct sockaddr_in6 sin6;
+//#endif
+//		}
+//	)
+//};
 /* Create stream socket, and allocate suitable lsa.
  * (lsa of correct size and lsa->sa.sa_family (AF_INET/AF_INET6))
  * af == AF_UNSPEC will result in trying to create IPv6 socket,
  * and if kernel doesn't support it, fall back to IPv4.
  * This is useful if you plan to bind to resulting local lsa.
  */
-int xsocket_type(len_and_sockaddr **lsap, int af, int sock_type) FAST_FUNC;
-int xsocket_stream(len_and_sockaddr **lsap) FAST_FUNC;
+//int xsocket_type(len_and_sockaddr **lsap, int af, int sock_type) FAST_FUNC;
+//int xsocket_stream(len_and_sockaddr **lsap) FAST_FUNC;
 /* Create server socket bound to bindaddr:port. bindaddr can be NULL,
  * numeric IP ("N.N.N.N") or numeric IPv6 address,
  * and can have ":PORT" suffix (for IPv6 use "[X:X:...:X]:PORT").
@@ -589,59 +600,59 @@ int create_and_bind_dgram_or_die(const c
  * If there is no suffix, port argument is used */
 int create_and_connect_stream_or_die(const char *peer, int port) FAST_FUNC;
 /* Connect to peer identified by lsa */
-int xconnect_stream(const len_and_sockaddr *lsa) FAST_FUNC;
+//int xconnect_stream(const len_and_sockaddr *lsa) FAST_FUNC;
 /* Get local address of bound or accepted socket */
-len_and_sockaddr *get_sock_lsa(int fd) FAST_FUNC RETURNS_MALLOC;
+//len_and_sockaddr *get_sock_lsa(int fd) FAST_FUNC RETURNS_MALLOC;
 /* Get remote address of connected or accepted socket */
-len_and_sockaddr *get_peer_lsa(int fd) FAST_FUNC RETURNS_MALLOC;
+//len_and_sockaddr *get_peer_lsa(int fd) FAST_FUNC RETURNS_MALLOC;
 /* Return malloc'ed len_and_sockaddr with socket address of host:port
  * Currently will return IPv4 or IPv6 sockaddrs only
  * (depending on host), but in theory nothing prevents e.g.
  * UNIX socket address being returned, IPX sockaddr etc...
  * On error does bb_error_msg and returns NULL */
-len_and_sockaddr* host2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
+//len_and_sockaddr* host2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
 /* Version which dies on error */
-len_and_sockaddr* xhost2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
-len_and_sockaddr* xdotted2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
+//len_and_sockaddr* xhost2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
+//len_and_sockaddr* xdotted2sockaddr(const char *host, int port) FAST_FUNC RETURNS_MALLOC;
 /* Same, useful if you want to force family (e.g. IPv6) */
 #if !ENABLE_FEATURE_IPV6
 #define host_and_af2sockaddr(host, port, af) host2sockaddr((host), (port))
 #define xhost_and_af2sockaddr(host, port, af) xhost2sockaddr((host), (port))
 #else
-len_and_sockaddr* host_and_af2sockaddr(const char *host, int port, sa_family_t af) FAST_FUNC RETURNS_MALLOC;
-len_and_sockaddr* xhost_and_af2sockaddr(const char *host, int port, sa_family_t af) FAST_FUNC RETURNS_MALLOC;
+//len_and_sockaddr* host_and_af2sockaddr(const char *host, int port, sa_family_t af) FAST_FUNC RETURNS_MALLOC;
+//len_and_sockaddr* xhost_and_af2sockaddr(const char *host, int port, sa_family_t af) FAST_FUNC RETURNS_MALLOC;
 #endif
 /* Assign sin[6]_port member if the socket is an AF_INET[6] one,
  * otherwise no-op. Useful for ftp.
  * NB: does NOT do htons() internally, just direct assignment. */
-void set_nport(struct sockaddr *sa, unsigned port) FAST_FUNC;
+//void set_nport(struct sockaddr *sa, unsigned port) FAST_FUNC;
 /* Retrieve sin[6]_port or return -1 for non-INET[6] lsa's */
-int get_nport(const struct sockaddr *sa) FAST_FUNC;
+//int get_nport(const struct sockaddr *sa) FAST_FUNC;
 /* Reverse DNS. Returns NULL on failure. */
-char* xmalloc_sockaddr2host(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
+//char* xmalloc_sockaddr2host(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
 /* This one doesn't append :PORTNUM */
-char* xmalloc_sockaddr2host_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
+//char* xmalloc_sockaddr2host_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
 /* This one also doesn't fall back to dotted IP (returns NULL) */
-char* xmalloc_sockaddr2hostonly_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
+//char* xmalloc_sockaddr2hostonly_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
 /* inet_[ap]ton on steroids */
-char* xmalloc_sockaddr2dotted(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
-char* xmalloc_sockaddr2dotted_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
+//char* xmalloc_sockaddr2dotted(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
+//char* xmalloc_sockaddr2dotted_noport(const struct sockaddr *sa) FAST_FUNC RETURNS_MALLOC;
 // "old" (ipv4 only) API
 // users: traceroute.c hostname.c - use _list_ of all IPs
-struct hostent *xgethostbyname(const char *name) FAST_FUNC;
+//struct hostent *xgethostbyname(const char *name) FAST_FUNC;
 // Also mount.c and inetd.c are using gethostbyname(),
 // + inet_common.c has additional IPv4-only stuff
 
 
 void socket_want_pktinfo(int fd) FAST_FUNC;
-ssize_t send_to_from(int fd, void *buf, size_t len, int flags,
-		const struct sockaddr *to,
-		const struct sockaddr *from,
-		socklen_t tolen) FAST_FUNC;
-ssize_t recv_from_to(int fd, void *buf, size_t len, int flags,
-		struct sockaddr *from,
-		struct sockaddr *to,
-		socklen_t sa_size) FAST_FUNC;
+//ss/ize_t send_to_from(int fd, void *buf, size_t len, int flags,
+//		const struct sockaddr *to,
+//		const struct sockaddr *from,
+//		socklen_t tolen) FAST_FUNC;
+//ssize_t recv_from_to(int fd, void *buf, size_t len, int flags,
+//		struct sockaddr *from,
+//		struct sockaddr *to,
+//		socklen_t sa_size) FAST_FUNC;
 
 uint16_t inet_cksum(uint16_t *addr, int len) FAST_FUNC;
 
@@ -805,7 +816,7 @@ void qsort_string_vector(char **sv, unsi
  * On other errors complains [perror("poll")] and returns.
  * Warning! May take (much) longer than timeout_ms to return!
  * If this is a problem, use bare poll and open-code EINTR/ENOMEM handling */
-int safe_poll(struct pollfd *ufds, nfds_t nfds, int timeout_ms) FAST_FUNC;
+//int safe_poll(struct pollfd *ufds, nfds_t nfds, int timeout_ms) FAST_FUNC;
 
 char *safe_gethostname(void) FAST_FUNC;
 
@@ -1123,20 +1134,20 @@ void bb_displayroutes(int noresolve, int
 
 /* Networking */
 /* This structure defines protocol families and their handlers. */
-struct aftype {
-	const char *name;
-	const char *title;
-	int af;
-	int alen;
-	char*       FAST_FUNC (*print)(unsigned char *);
-	const char* FAST_FUNC (*sprint)(struct sockaddr *, int numeric);
-	int         FAST_FUNC (*input)(/*int type,*/ const char *bufp, struct sockaddr *);
-	void        FAST_FUNC (*herror)(char *text);
-	int         FAST_FUNC (*rprint)(int options);
-	int         FAST_FUNC (*rinput)(int typ, int ext, char **argv);
-	/* may modify src */
-	int         FAST_FUNC (*getmask)(char *src, struct sockaddr *mask, char *name);
-};
+//istruct aftype {
+//	const char *name;
+//	const char *title;
+//	int af;
+//	int alen;
+//	char*       FAST_FUNC (*print)(unsigned char *);
+//	const char* FAST_FUNC (*sprint)(struct sockaddr *, int numeric);
+//	int         FAST_FUNC (*input)(/*int type,*/ const char *bufp, struct sockaddr *);
+//	void        FAST_FUNC (*herror)(char *text);
+//	int         FAST_FUNC (*rprint)(int options);
+//	int         FAST_FUNC (*rinput)(int typ, int ext, char **argv);
+//	/* may modify src */
+//	int         FAST_FUNC (*getmask)(char *src, struct sockaddr *mask, char *name);
+//};
 /* This structure defines hardware protocols and their handlers. */
 struct hwtype {
 	const char *name;
@@ -1144,21 +1155,21 @@ struct hwtype {
 	int type;
 	int alen;
 	char* FAST_FUNC (*print)(unsigned char *);
-	int   FAST_FUNC (*input)(const char *, struct sockaddr *);
+//	int   FAST_FUNC (*input)(const char *, struct sockaddr *);
 	int   FAST_FUNC (*activate)(int fd);
 	int suppress_null_addr;
 };
-extern smallint interface_opt_a;
-int display_interfaces(char *ifname) FAST_FUNC;
-int in_ether(const char *bufp, struct sockaddr *sap) FAST_FUNC;
+//extern smallint interface_opt_a;
+//int display_interfaces(char *ifname) FAST_FUNC;
+//int in_ether(const char *bufp, struct sockaddr *sap) FAST_FUNC;
 #if ENABLE_FEATURE_HWIB
-int in_ib(const char *bufp, struct sockaddr *sap) FAST_FUNC;
+//int in_ib(const char *bufp, struct sockaddr *sap) FAST_FUNC;
 #else
 #define in_ib(a, b) 1 /* fail */
 #endif
-const struct aftype *get_aftype(const char *name) FAST_FUNC;
-const struct hwtype *get_hwtype(const char *name) FAST_FUNC;
-const struct hwtype *get_hwntype(int type) FAST_FUNC;
+//const struct aftype *get_aftype(const char *name) FAST_FUNC;
+//const struct hwtype *get_hwtype(const char *name) FAST_FUNC;
+//const struct hwtype *get_hwntype(int type) FAST_FUNC;
 
 
 #ifndef BUILD_INDIVIDUAL
@@ -1169,8 +1180,8 @@ extern void run_applet_no_and_exit(int a
 #endif
 
 #ifdef HAVE_MNTENT_H
-extern int match_fstype(const struct mntent *mt, const char *fstypes) FAST_FUNC;
-extern struct mntent *find_mount_point(const char *name, int subdir_too) FAST_FUNC;
+//extern int match_fstype(const struct mntent *mt, const char *fstypes) FAST_FUNC;
+//extern struct mntent *find_mount_point(const char *name, int subdir_too) FAST_FUNC;
 #endif
 extern void erase_mtab(const char * name) FAST_FUNC;
 extern unsigned int tty_baud_to_value(speed_t speed) FAST_FUNC;
diff -rupN busybox-1.22.1/include/platform.h ../src3m/busybox-1.22.1/include/platform.h
--- busybox-1.22.1/include/platform.h	2014-01-20 03:38:10.000000000 +0100
+++ ../src3m/busybox-1.22.1/include/platform.h	2020-05-16 03:16:19.165660705 +0200
@@ -146,8 +146,8 @@
 # define bswap_32 __bswap32
 # define bswap_16 __bswap16
 #else
-# include <byteswap.h>
-# include <endian.h>
+//### include <byteswap.h>
+//#### include <endian.h>
 #endif
 
 #if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN
@@ -172,7 +172,9 @@
 # define BB_BIG_ENDIAN 0
 # define BB_LITTLE_ENDIAN 1
 #else
-# error "Can't determine endianness"
+//# error "Can't determine endianness"
+#define BB_BIG_ENDIAN 0
+#define BB_LITTLE_ENDIAN 1
 #endif
 
 #if ULONG_MAX > 0xffffffff
@@ -278,7 +280,7 @@ typedef unsigned smalluint;
  || defined __dietlibc__ \
  || defined __BIONIC__ \
  || defined _NEWLIB_VERSION
-# include <features.h>
+//# include <features.h>
 #endif
 
 /* Define bb_setpgrp */
diff -rupN busybox-1.22.1/libbb/bb_bswap_64.c ../src3m/busybox-1.22.1/libbb/bb_bswap_64.c
--- busybox-1.22.1/libbb/bb_bswap_64.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/bb_bswap_64.c	2020-05-16 03:16:19.165660705 +0200
@@ -8,9 +8,14 @@
 
 #include "libbb.h"
 
+#define BSWAP_8(x)      ((x) & 0xff)
+#define BSWAP_16(x)     ((BSWAP_8(x) << 8) | BSWAP_8((x) >> 8))
+#define BSWAP_32(x)     ((BSWAP_16(x) << 16) | BSWAP_16((x) >> 16))
+#define BSWAP_64(x)     ((BSWAP_32(x) << 32) | BSWAP_32((x) >> 32))
+
 #if !(ULONG_MAX > 0xffffffff)
 uint64_t FAST_FUNC bb_bswap_64(uint64_t x)
 {
-	return bswap_64(x);
+	return BSWAP_64(x);
 }
 #endif
diff -rupN busybox-1.22.1/libbb/bb_pwd.c ../src3m/busybox-1.22.1/libbb/bb_pwd.c
--- busybox-1.22.1/libbb/bb_pwd.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/bb_pwd.c	2020-05-16 03:16:19.165660705 +0200
@@ -25,10 +25,10 @@ struct passwd* FAST_FUNC xgetpwnam(const
 
 struct group* FAST_FUNC xgetgrnam(const char *name)
 {
-	struct group *gr = getgrnam(name);
-	if (!gr)
+	//struct group *gr = getgrnam(name);
+//	if (!gr)
 		bb_error_msg_and_die("unknown group %s", name);
-	return gr;
+//	return gr;
 }
 
 
diff -rupN busybox-1.22.1/libbb/getopt32.c ../src3m/busybox-1.22.1/libbb/getopt32.c
--- busybox-1.22.1/libbb/getopt32.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/getopt32.c	2020-05-16 03:16:19.165660705 +0200
@@ -4,12 +4,10 @@
  *
  * Copyright (C) 2003-2005  Vladimir Oleynik  <dzo@simtreas.ru>
  *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
  */
 
-#if ENABLE_LONG_OPTS || ENABLE_FEATURE_GETOPT_LONG
-# include <getopt.h>
-#endif
+#include <getopt.h>
 #include "libbb.h"
 
 /*      Documentation
@@ -82,9 +80,9 @@ const char *applet_long_options
         This struct allows you to define long options:
 
         static const char applet_longopts[] ALIGN1 =
-                //"name\0" has_arg val
-                "verbose\0" No_argument "v"
-                ;
+		//"name\0" has_arg val
+		"verbose\0" No_argument "v"
+		;
         applet_long_options = applet_longopts;
 
         The last member of struct option (val) typically is set to
@@ -117,7 +115,7 @@ const char *opt_complementary
         found.
 
  "ww"   Adjacent double options have a counter associated which indicates
-        the number of occurrences of the option.
+        the number of occurences of the option.
         For example the ps applet needs:
         if w is given once, GNU ps sets the width to 132,
         if w is given more than once, it is "unlimited"
@@ -228,14 +226,14 @@ Special characters:
         if specified together.  In this case you must set
         opt_complementary = "b--cf:c--bf:f--bc".  If two of the
         mutually exclusive options are found, getopt32 will call
-        bb_show_usage() and die.
+	bb_show_usage() and die.
 
  "x--x" Variation of the above, it means that -x option should occur
         at most once.
 
  "a+"   A plus after a char in opt_complementary means that the parameter
         for this option is a nonnegative integer. It will be processed
-        with xatoi_positive() - allowed range is 0..INT_MAX.
+        with xatoi_u() - allowed range is 0..INT_MAX.
 
         int param;  // "unsigned param;" will also work
         opt_complementary = "p+";
@@ -467,17 +465,13 @@ getopt32(char **argv, const char *applet
 		}
 		for (on_off = complementary; on_off->opt_char; on_off++)
 			if (on_off->opt_char == *s)
-				goto found_opt;
-		/* Without this, diagnostic of such bugs is not easy */
-		bb_error_msg_and_die("NO OPT %c!", *s);
- found_opt:
+				break;
 		if (c == ':' && s[2] == ':') {
 			on_off->param_type = PARAM_LIST;
 			continue;
 		}
 		if (c == '+' && (s[2] == ':' || s[2] == '\0')) {
 			on_off->param_type = PARAM_INT;
-			s++;
 			continue;
 		}
 		if (c == ':' || c == '\0') {
@@ -537,7 +531,7 @@ getopt32(char **argv, const char *applet
 
 	/* In case getopt32 was already called:
 	 * reset the libc getopt() function, which keeps internal state.
-	 * run_nofork_applet() does this, but we might end up here
+	 * run_nofork_applet_prime() does this, but we might end up here
 	 * also via gunzip_main() -> gzip_main(). Play safe.
 	 */
 #ifdef __GLIBC__
@@ -548,6 +542,8 @@ getopt32(char **argv, const char *applet
 #endif
 	/* optarg = NULL; opterr = 0; optopt = 0; - do we need this?? */
 
+	pargv = NULL;
+
 	/* Note: just "getopt() <= 0" will not work well for
 	 * "fake" short options, like this one:
 	 * wget $'-\203' "Test: test" http://kernel.org/
@@ -578,16 +574,19 @@ getopt32(char **argv, const char *applet
 		flags ^= trigger;
 		if (on_off->counter)
 			(*(on_off->counter))++;
-		if (optarg) {
-			if (on_off->param_type == PARAM_LIST) {
+		if (on_off->param_type == PARAM_LIST) {
+			if (optarg)
 				llist_add_to_end((llist_t **)(on_off->optarg), optarg);
-			} else if (on_off->param_type == PARAM_INT) {
-//TODO: xatoi_positive indirectly pulls in printf machinery
-				*(unsigned*)(on_off->optarg) = xatoi_positive(optarg);
-			} else if (on_off->optarg) {
+		} else if (on_off->param_type == PARAM_INT) {
+			if (optarg)
+//TODO: xatoi_u indirectly pulls in printf machinery
+				*(unsigned*)(on_off->optarg) = atoi(optarg);
+		} else if (on_off->optarg) {
+			if (optarg)
 				*(char **)(on_off->optarg) = optarg;
-			}
 		}
+		if (pargv != NULL)
+			break;
 	}
 
 	/* check depending requires for given options */
@@ -613,3 +612,4 @@ getopt32(char **argv, const char *applet
 		bb_show_usage();
 	return (int32_t)-1;
 }
+
diff -rupN busybox-1.22.1/libbb/herror_msg.c ../src3m/busybox-1.22.1/libbb/herror_msg.c
--- busybox-1.22.1/libbb/herror_msg.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/herror_msg.c	2020-05-16 03:16:19.165660705 +0200
@@ -13,7 +13,7 @@ void FAST_FUNC bb_herror_msg(const char
 	va_list p;
 
 	va_start(p, s);
-	bb_verror_msg(s, p, hstrerror(h_errno));
+//	bb_verror_msg(s, p, hstrerror(0));h_errno));
 	va_end(p);
 }
 
@@ -22,7 +22,7 @@ void FAST_FUNC bb_herror_msg_and_die(con
 	va_list p;
 
 	va_start(p, s);
-	bb_verror_msg(s, p, hstrerror(h_errno));
+//	bb_verror_msg(s, p,0);// hstrerror(h_errno));
 	va_end(p);
 	xfunc_die();
 }
diff -rupN busybox-1.22.1/libbb/inet_common.c ../src3m/busybox-1.22.1/libbb/inet_common.c
--- busybox-1.22.1/libbb/inet_common.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/inet_common.c	2020-05-16 03:16:19.165660705 +0200
@@ -10,7 +10,7 @@
 
 #include "libbb.h"
 #include "inet_common.h"
-
+#ifdef NOTDEFD
 int FAST_FUNC INET_resolve(const char *name, struct sockaddr_in *s_in, int hostfirst)
 {
 	struct hostent *hp;
@@ -221,3 +221,4 @@ char* FAST_FUNC INET6_rresolve(struct so
 }
 
 #endif  /* CONFIG_FEATURE_IPV6 */
+#endif
diff -rupN busybox-1.22.1/libbb/info_msg.c ../src3m/busybox-1.22.1/libbb/info_msg.c
--- busybox-1.22.1/libbb/info_msg.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/info_msg.c	2020-05-16 03:16:19.165660705 +0200
@@ -8,9 +8,6 @@
  */
 
 #include "libbb.h"
-#if ENABLE_FEATURE_SYSLOG
-# include <syslog.h>
-#endif
 
 void FAST_FUNC bb_info_msg(const char *s, ...)
 {
@@ -26,13 +23,8 @@ void FAST_FUNC bb_info_msg(const char *s
 		vprintf(s, p);
 		fputs(msg_eol, stdout);
 	}
-# if ENABLE_FEATURE_SYSLOG
-	if (logmode & LOGMODE_SYSLOG)
-		vsyslog(LOG_INFO, s, p2);
-# endif
 	va_end(p2);
 	va_end(p);
-#else
 	int used;
 	char *msg;
 	va_list p;
@@ -46,10 +38,7 @@ void FAST_FUNC bb_info_msg(const char *s
 	if (used < 0)
 		return;
 
-# if ENABLE_FEATURE_SYSLOG
-	if (logmode & LOGMODE_SYSLOG)
-		syslog(LOG_INFO, "%s", msg);
-# endif
+
 	if (logmode & LOGMODE_STDIO) {
 		fflush_all();
 		/* used = strlen(msg); - must be true already */
diff -rupN busybox-1.22.1/libbb/kernel_version.c ../src3m/busybox-1.22.1/libbb/kernel_version.c
--- busybox-1.22.1/libbb/kernel_version.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/kernel_version.c	2020-05-16 03:16:19.165660705 +0200
@@ -9,7 +9,7 @@
 
 #include "libbb.h"
 /* After libbb.h, since it needs sys/types.h on some systems */
-#include <sys/utsname.h>  /* for uname(2) */
+//#include <sys/utsname.h>  /* for uname(2) */
 
 
 /* Returns current kernel version encoded as major*65536 + minor*256 + patch,
@@ -19,11 +19,13 @@
  */
 int FAST_FUNC get_linux_version_code(void)
 {
+	return 123;
+/*
 	struct utsname name;
 	char *s, *t;
 	int i, r;
 
-	uname(&name); /* never fails */
+	//uname(&name); / * never fails * /
 	s = name.release;
 	r = 0;
 	for (i = 0; i < 3; i++) {
@@ -32,4 +34,5 @@ int FAST_FUNC get_linux_version_code(voi
 		s = NULL;
 	}
 	return r;
+}*/
 }
diff -rupN busybox-1.22.1/libbb/login.c ../src3m/busybox-1.22.1/libbb/login.c
--- busybox-1.22.1/libbb/login.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/login.c	2020-05-16 03:16:19.165660705 +0200
@@ -11,7 +11,7 @@
 
 #include "libbb.h"
 /* After libbb.h, since it needs sys/types.h on some systems */
-#include <sys/utsname.h>
+//#include <sys/utsname.h>
 
 #define LOGIN " login: "
 
@@ -24,10 +24,10 @@ void FAST_FUNC print_login_issue(const c
 	char buf[256+1];
 	const char *outbuf;
 	time_t t;
-	struct utsname uts;
+	///struct utsname uts;
 
 	time(&t);
-	uname(&uts);
+	//uname(&uts);
 
 	puts("\r");  /* start a new line */
 
@@ -46,26 +46,26 @@ void FAST_FUNC print_login_issue(const c
 			c = fgetc(fp);
 			switch (c) {
 			case 's':
-				outbuf = uts.sysname;
+				outbuf = "P-OS";//uts.sysname;
 				break;
 			case 'n':
 			case 'h':
-				outbuf = uts.nodename;
+				outbuf = "posnk_testvm";
 				break;
 			case 'r':
-				outbuf = uts.release;
+				outbuf = "0.01";
 				break;
 			case 'v':
-				outbuf = uts.version;
+				outbuf = "0.01";
 				break;
 			case 'm':
-				outbuf = uts.machine;
+				outbuf = "i386";
 				break;
 /* The field domainname of struct utsname is Linux specific. */
 #if defined(__linux__)
 			case 'D':
 			case 'o':
-				outbuf = uts.domainname;
+				outbuf = "posnk_testvm";
 				break;
 #endif
 			case 'd':
diff -rupN busybox-1.22.1/libbb/makedev.c ../src3m/busybox-1.22.1/libbb/makedev.c
--- busybox-1.22.1/libbb/makedev.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/makedev.c	2020-05-16 03:16:19.165660705 +0200
@@ -14,8 +14,8 @@
  || defined(__APPLE__)
 # include <sys/types.h>
 #else
-# include <features.h>
-# include <sys/sysmacros.h>
+//# include <features.h>
+//# include <sys/sysmacros.h>
 #endif
 
 #ifdef __GLIBC__
@@ -26,6 +26,6 @@
 unsigned long long FAST_FUNC bb_makedev(unsigned major, unsigned minor);
 unsigned long long FAST_FUNC bb_makedev(unsigned major, unsigned minor)
 {
-	return makedev(major, minor);
+	return MKDEV(major, minor);
 }
 #endif
diff -rupN busybox-1.22.1/libbb/match_fstype.c ../src3m/busybox-1.22.1/libbb/match_fstype.c
--- busybox-1.22.1/libbb/match_fstype.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/match_fstype.c	2020-05-16 03:16:19.165660705 +0200
@@ -16,7 +16,7 @@
 
 int FAST_FUNC match_fstype(const struct mntent *mt, const char *t_fstype)
 {
-	int match = 1;
+	/*int match = 1;
 	int len;
 
 	if (!t_fstype)
@@ -39,8 +39,8 @@ int FAST_FUNC match_fstype(const struct
 			break;
 		t_fstype++;
 	}
-
-	return !match;
+*/
+	return 0;//!match;
 }
 
 #endif /* HAVE_MNTENT_H */
diff -rupN busybox-1.22.1/libbb/missing_syscalls.c ../src3m/busybox-1.22.1/libbb/missing_syscalls.c
--- busybox-1.22.1/libbb/missing_syscalls.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/missing_syscalls.c	2020-05-16 03:16:19.165660705 +0200
@@ -7,7 +7,8 @@
 //kbuild:lib-y += missing_syscalls.o
 
 /*#include <linux/timex.h> - for struct timex, but may collide with <time.h> */
-#include <sys/syscall.h>
+#ifdef NOTDEF
+//#include <sys/syscall.h>
 #include "libbb.h"
 
 #if defined(ANDROID) || defined(__ANDROID__)
@@ -40,3 +41,4 @@ int pivot_root(const char *new_root, con
 	return syscall(__NR_pivot_root, new_root, put_old);
 }
 #endif
+#endif
diff -rupN busybox-1.22.1/libbb/read_key.c ../src3m/busybox-1.22.1/libbb/read_key.c
--- busybox-1.22.1/libbb/read_key.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/read_key.c	2020-05-16 03:16:19.165660705 +0200
@@ -8,7 +8,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 #include "libbb.h"
-
+#ifdef NOTDEF
 int64_t FAST_FUNC read_key(int fd, char *buffer, int timeout)
 {
 	struct pollfd pfd;
@@ -279,3 +279,4 @@ void FAST_FUNC read_key_ungets(char *buf
 	memcpy(buffer + 1 + cur_len, str, len);
 	buffer[0] += len;
 }
+#endif
diff -rupN busybox-1.22.1/libbb/read_printf.c ../src3m/busybox-1.22.1/libbb/read_printf.c
--- busybox-1.22.1/libbb/read_printf.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/read_printf.c	2020-05-16 03:16:19.165660705 +0200
@@ -47,19 +47,20 @@
  */
 ssize_t FAST_FUNC nonblock_immune_read(int fd, void *buf, size_t count, int loop_on_EINTR)
 {
-	struct pollfd pfd[1];
+	/*struct pollfd pfd[1];
 	ssize_t n;
 
 	while (1) {
 		n = loop_on_EINTR ? safe_read(fd, buf, count) : read(fd, buf, count);
 		if (n >= 0 || errno != EAGAIN)
 			return n;
-		/* fd is in O_NONBLOCK mode. Wait using poll and repeat */
+		/* fd is in O_NONBLOCK mode. Wait using poll and repeat * /
 		pfd[0].fd = fd;
 		pfd[0].events = POLLIN;
-		/* note: safe_poll pulls in printf */
+		/* note: safe_poll pulls in printf * /
 		loop_on_EINTR ? safe_poll(pfd, 1, -1) : poll(pfd, 1, -1);
-	}
+	}*/
+	return read(fd, buf, count);
 }
 
 // Reads one line a-la fgets (but doesn't save terminating '\n').
diff -rupN busybox-1.22.1/libbb/safe_gethostname.c ../src3m/busybox-1.22.1/libbb/safe_gethostname.c
--- busybox-1.22.1/libbb/safe_gethostname.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/safe_gethostname.c	2020-05-16 03:16:19.165660705 +0200
@@ -25,7 +25,7 @@
  */
 
 #include "libbb.h"
-#include <sys/utsname.h>
+//#include <sys/utsname.h>
 
 /*
  * On success return the current malloced and NUL terminated hostname.
@@ -35,7 +35,7 @@
  */
 char* FAST_FUNC safe_gethostname(void)
 {
-	struct utsname uts;
+	//struct utsname uts;
 
 	/* The length of the arrays in a struct utsname is unspecified;
 	 * the fields are terminated by a null byte.
@@ -47,6 +47,6 @@ char* FAST_FUNC safe_gethostname(void)
 	 */
 
 	/* Uname can fail only if you pass a bad pointer to it. */
-	uname(&uts);
-	return xstrndup(!uts.nodename[0] ? "?" : uts.nodename, sizeof(uts.nodename));
+	//uname(&uts);
+	return xstrndup("posnt_testvm", 138);
 }
diff -rupN busybox-1.22.1/libbb/safe_poll.c ../src3m/busybox-1.22.1/libbb/safe_poll.c
--- busybox-1.22.1/libbb/safe_poll.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/safe_poll.c	2020-05-16 03:16:19.165660705 +0200
@@ -12,23 +12,7 @@
 /* Wrapper which restarts poll on EINTR or ENOMEM.
  * On other errors does perror("poll") and returns.
  * Warning! May take longer than timeout_ms to return! */
-int FAST_FUNC safe_poll(struct pollfd *ufds, nfds_t nfds, int timeout)
-{
-	while (1) {
-		int n = poll(ufds, nfds, timeout);
-		if (n >= 0)
-			return n;
-		/* Make sure we inch towards completion */
-		if (timeout > 0)
-			timeout--;
-		/* E.g. strace causes poll to return this */
-		if (errno == EINTR)
-			continue;
-		/* Kernel is very low on memory. Retry. */
-		/* I doubt many callers would handle this correctly! */
-		if (errno == ENOMEM)
-			continue;
-		bb_perror_msg("poll");
-		return n;
-	}
-}
+//int FAST_FUNC safe_poll(struct pollfd *ufds, nfds_t nfds, int timeout)
+//{
+//		return 0;
+//}//
diff -rupN busybox-1.22.1/libbb/signals.c ../src3m/busybox-1.22.1/libbb/signals.c
--- busybox-1.22.1/libbb/signals.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/signals.c	2020-05-16 03:16:19.165660705 +0200
@@ -10,6 +10,7 @@
  */
 
 #include "libbb.h"
+#include <signal.h>
 
 /* All known arches use small ints for signals */
 smallint bb_got_signal;
@@ -19,10 +20,12 @@ void record_signo(int signo)
 	bb_got_signal = signo;
 }
 
+
+
 /* Saves 2 bytes on x86! Oh my... */
 int FAST_FUNC sigaction_set(int signum, const struct sigaction *act)
 {
-	return sigaction(signum, act, NULL);
+	return 0;//return sigaction(signum, act, NULL);
 }
 
 int FAST_FUNC sigprocmask_allsigs(int how)
@@ -61,7 +64,7 @@ void FAST_FUNC bb_signals_recursive_nore
 	while (sigs) {
 		if (sigs & bit) {
 			sigs -= bit;
-			sigaction_set(sig_no, &sa);
+			signal(sig_no, f);
 		}
 		sig_no++;
 		bit <<= 1;
@@ -105,9 +108,9 @@ void FAST_FUNC signal_SA_RESTART_empty_m
 	struct sigaction sa;
 	memset(&sa, 0, sizeof(sa));
 	/*sigemptyset(&sa.sa_mask);*/
-	sa.sa_flags = SA_RESTART;
+	sa.sa_flags = 0;//qSA_IGNORE;
 	sa.sa_handler = handler;
-	sigaction_set(sig, &sa);
+	signal(sig, handler);
 }
 
 void FAST_FUNC signal_no_SA_RESTART_empty_mask(int sig, void (*handler)(int))
@@ -117,5 +120,6 @@ void FAST_FUNC signal_no_SA_RESTART_empt
 	/*sigemptyset(&sa.sa_mask);*/
 	/*sa.sa_flags = 0;*/
 	sa.sa_handler = handler;
-	sigaction_set(sig, &sa);
+	//sigaction_set(sig, &sa);
+	signal(sig, handler);
 }
diff -rupN busybox-1.22.1/libbb/verror_msg.c ../src3m/busybox-1.22.1/libbb/verror_msg.c
--- busybox-1.22.1/libbb/verror_msg.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/verror_msg.c	2020-05-16 03:16:19.165660705 +0200
@@ -7,9 +7,6 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 #include "libbb.h"
-#if ENABLE_FEATURE_SYSLOG
-# include <syslog.h>
-#endif
 
 smallint logmode = LOGMODE_STDIO;
 const char *msg_eol = "\n";
@@ -68,11 +65,6 @@ void FAST_FUNC bb_verror_msg(const char
 		fflush_all();
 		full_write(STDERR_FILENO, msg, used);
 	}
-#if ENABLE_FEATURE_SYSLOG
-	if (logmode & LOGMODE_SYSLOG) {
-		syslog(LOG_ERR, "%s", msg + applet_len);
-	}
-#endif
 	free(msg);
 }
 
@@ -128,11 +120,6 @@ void FAST_FUNC bb_verror_msg(const char
 		fflush_all();
 		writev(STDERR_FILENO, iov, 3);
 	}
-# if ENABLE_FEATURE_SYSLOG
-	if (logmode & LOGMODE_SYSLOG) {
-		syslog(LOG_ERR, "%s", msgc);
-	}
-# endif
 	free(msgc);
 }
 #endif
diff -rupN busybox-1.22.1/libbb/xconnect.c ../src3m/busybox-1.22.1/libbb/xconnect.c
--- busybox-1.22.1/libbb/xconnect.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/xconnect.c	2020-05-16 03:16:19.165660705 +0200
@@ -6,7 +6,7 @@
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
-
+#ifdef NOTDEFD
 #include <sys/types.h>
 #include <sys/socket.h> /* netinet/in.h needs it */
 #include <netinet/in.h>
@@ -484,3 +484,4 @@ char* FAST_FUNC xmalloc_sockaddr2dotted_
 {
 	return sockaddr2str(sa, NI_NUMERICHOST | IGNORE_PORT);
 }
+#endif
diff -rupN busybox-1.22.1/libbb/xfunc_die.c ../src3m/busybox-1.22.1/libbb/xfunc_die.c
--- busybox-1.22.1/libbb/xfunc_die.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/xfunc_die.c	2020-05-16 03:16:19.165660705 +0200
@@ -19,7 +19,7 @@ jmp_buf die_jmp;
 
 void FAST_FUNC xfunc_die(void)
 {
-	if (die_sleep) {
+	/*if (die_sleep) {
 		if ((ENABLE_FEATURE_PREFER_APPLETS || ENABLE_HUSH)
 		 && die_sleep < 0
 		) {
@@ -31,10 +31,10 @@ void FAST_FUNC xfunc_die(void)
 			 * q = xmalloc(10); // BUG! if this dies, we leak p!
 			 */
 			/* -2222 means "zero" (longjmp can't pass 0)
-			 * run_nofork_applet() catches -2222. */
+			 * run_nofork_applet() catches -2222. * /
 			longjmp(die_jmp, xfunc_error_retval ? xfunc_error_retval : -2222);
 		}
 		sleep(die_sleep);
-	}
+	}*/
 	exit(xfunc_error_retval);
 }
diff -rupN busybox-1.22.1/libbb/xfuncs.c ../src3m/busybox-1.22.1/libbb/xfuncs.c
--- busybox-1.22.1/libbb/xfuncs.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/xfuncs.c	2020-05-16 18:51:02.667787168 +0200
@@ -258,8 +258,8 @@ int FAST_FUNC get_terminal_width_height(
 	struct winsize win;
 	int err;
 
-	win.ws_row = 0;
-	win.ws_col = 0;
+	win.ws_row = 80;
+	win.ws_col = 25;
 	/* I've seen ioctl returning 0, but row/col is (still?) 0.
 	 * We treat that as an error too.  */
 	err = ioctl(fd, TIOCGWINSZ, &win) != 0 || win.ws_row == 0;
@@ -267,6 +267,10 @@ int FAST_FUNC get_terminal_width_height(
 		*height = wh_helper(win.ws_row, 24, "LINES", &err);
 	if (width)
 		*width = wh_helper(win.ws_col, 80, "COLUMNS", &err);
+//	if (width)
+//		*width = 80;
+//	if (height)
+//		*height = 25;
 	return err;
 }
 
diff -rupN busybox-1.22.1/libbb/xgethostbyname.c ../src3m/busybox-1.22.1/libbb/xgethostbyname.c
--- busybox-1.22.1/libbb/xgethostbyname.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libbb/xgethostbyname.c	2020-05-16 03:16:19.165660705 +0200
@@ -6,12 +6,12 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
-#include "libbb.h"
-
+//#include "libbb.h"
+/*
 struct hostent* FAST_FUNC xgethostbyname(const char *name)
 {
 	struct hostent *retval = gethostbyname(name);
 	if (!retval)
 		bb_herror_msg_and_die("%s", name);
 	return retval;
-}
+}*/
diff -rupN busybox-1.22.1/libpwdgrp/uidgid_get.c ../src3m/busybox-1.22.1/libpwdgrp/uidgid_get.c
--- busybox-1.22.1/libpwdgrp/uidgid_get.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/libpwdgrp/uidgid_get.c	2020-05-16 03:16:19.165660705 +0200
@@ -70,10 +70,10 @@ int FAST_FUNC get_uidgid(struct bb_uidgi
 				return 1;
 			}
 		}
-		gr = getgrnam(group);
-		if (!gr)
+		//gr = getgrnam(group);
+		//if (!gr)
 			return 0;
-		u->gid = gr->gr_gid;
+		//u->gid = gr->gr_gid;
 	}
 	return 1;
 }
diff -rupN busybox-1.22.1/loginutils/getty.c ../src3m/busybox-1.22.1/loginutils/getty.c
--- busybox-1.22.1/loginutils/getty.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/loginutils/getty.c	2020-05-16 03:16:19.165660705 +0200
@@ -23,7 +23,6 @@
  */
 
 #include "libbb.h"
-#include <syslog.h>
 #ifndef IUCLC
 # define IUCLC 0
 #endif
@@ -341,7 +340,7 @@ static void finalize_tty_attrs(void)
 	 * echo kill char specially, not as ^c (ECHOKE controls how exactly);
 	 * erase all input via BS-SP-BS on kill char (else go to next line)
 	 */
-	G.tty_attrs.c_lflag |= ICANON | ISIG | ECHO | ECHOE | ECHOK | ECHOKE;
+	G.tty_attrs.c_lflag |= ICANON | ISIG | ECHO | ECHOE | ECHOK;
 	/* Other bits in c_lflag:
 	 * XCASE   Map uppercase to \lowercase [tried, doesn't work]
 	 * ECHONL  Echo NL even if ECHO is not set
@@ -591,7 +590,6 @@ int getty_main(int argc UNUSED_PARAM, ch
 	die_sleep = 10;
 	msg_eol = "\r\n";
 	/* most likely will internally use fd #3 in CLOEXEC mode: */
-	openlog(applet_name, LOG_PID, LOG_AUTH);
 	logmode = LOGMODE_BOTH;
 
 #ifdef DEBUGGING
diff -rupN busybox-1.22.1/loginutils/login.c ../src3m/busybox-1.22.1/loginutils/login.c
--- busybox-1.22.1/loginutils/login.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/loginutils/login.c	2020-05-16 03:16:19.165660705 +0200
@@ -12,7 +12,6 @@
 //usage:     "\n	-p	Preserve environment"
 
 #include "libbb.h"
-#include <syslog.h>
 #include <sys/resource.h>
 
 #if ENABLE_SELINUX
diff -rupN busybox-1.22.1/shell/ash.c ../src3m/busybox-1.22.1/shell/ash.c
--- busybox-1.22.1/shell/ash.c	2014-01-20 03:38:10.000000000 +0100
+++ ../src3m/busybox-1.22.1/shell/ash.c	2020-05-16 03:16:19.169660734 +0200
@@ -34,7 +34,7 @@
 #define DEBUG_SIG 1
 
 #define PROFILE 0
-
+#define _PATH_TTY xmalloc_ttyname(STDIN_FILENO)
 #define JOBS ENABLE_ASH_JOB_CONTROL
 
 #include <paths.h>
@@ -3489,8 +3489,8 @@ setsignal(int signo)
 	 */
 	act.sa_flags = 0;
 	sigfillset(&act.sa_mask);
-
-	sigaction_set(signo, &act);
+	signal(signo, act.sa_handler);
+	//sigaction_set(signo, &act);
 
 	*t = new_act;
 }
@@ -3915,9 +3915,9 @@ sprint_status(char *s, int status, int s
 		st &= 0x7f;
 //TODO: use bbox's get_signame? strsignal adds ~600 bytes to text+rodata
 		col = fmtstr(s, 32, strsignal(st));
-		if (WCOREDUMP(status)) {
-			col += fmtstr(s + col, 16, " (core dumped)");
-		}
+	///	if (WCOREDUMP(status)) {
+	///		col += fmtstr(s + col, 16, " (core dumped)");
+	///	}
 	} else if (!sigonly) {
 		st = WEXITSTATUS(status);
 		if (st)
diff -rupN busybox-1.22.1/shell/shell_common.c ../src3m/busybox-1.22.1/shell/shell_common.c
--- busybox-1.22.1/shell/shell_common.c	2014-01-09 19:15:44.000000000 +0100
+++ ../src3m/busybox-1.22.1/shell/shell_common.c	2020-05-16 03:16:19.169660734 +0200
@@ -55,7 +55,10 @@ shell_builtin_read(void FAST_FUNC (*setv
 	const char *opt_t,
 	const char *opt_u
 )
+
 {
+	return 0;
+#ifdef NOTDEF
 	unsigned err;
 	unsigned end_ms; /* -t TIMEOUT */
 	int fd; /* -u FD */
@@ -269,6 +272,7 @@ shell_builtin_read(void FAST_FUNC (*setv
 
 	errno = err;
 	return retval;
+#endif
 }
 
 /* ulimit builtin */
@@ -373,18 +377,18 @@ static const char ulimit_opt_string[] =
 static void printlim(unsigned opts, const struct rlimit *limit,
 			const struct limits *l)
 {
-	rlim_t val;
-
-	val = limit->rlim_max;
-	if (!(opts & OPT_hard))
-		val = limit->rlim_cur;
-
-	if (val == RLIM_INFINITY)
+//	rlim_t val;
+//
+	//val = limit->rlim_max;
+	//if (!(opts & OPT_hard))
+//	/	val = limit->rlim_cur;
+//
+	//if (val == RLIM_INFINITY)
 		printf("unlimited\n");
-	else {
-		val >>= l->factor_shift;
-		printf("%llu\n", (long long) val);
-	}
+	//else {
+//		val >>= l->factor_shift;
+	//	printf("%llu\n", (long long) val);
+	//}
 }
 
 int FAST_FUNC
@@ -392,7 +396,7 @@ shell_builtin_ulimit(char **argv)
 {
 	unsigned opts;
 	unsigned argc;
-
+#ifdef NOTDEF
 	/* We can't use getopt32: need to handle commands like
 	 * ulimit 123 -c2 -l 456
 	 */
@@ -495,6 +499,6 @@ shell_builtin_ulimit(char **argv)
 		}
 
 	} /* while (there are options) */
-
+#endif
 	return 0;
 }
